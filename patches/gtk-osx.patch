Index: gtk/gtkquartz.c
===================================================================
--- gtk/gtkquartz.c	(revision 21737)
+++ gtk/gtkquartz.c	(working copy)
@@ -24,6 +24,23 @@
 #include "gtkalias.h"
 
 NSImage *
+_gtk_quartz_create_image_from_drawable (GdkDrawable* drawable)
+{
+	GdkPixbuf* pixbuf;
+	NSImage* image = NULL;
+
+	pixbuf = gdk_pixbuf_get_from_drawable (NULL, drawable, NULL, 
+						  0, 0, /* src */
+						  0, 0, /* dst */
+						  -1, -1);
+	if (pixbuf) 
+   	  image = _gtk_quartz_create_image_from_pixbuf (pixbuf);
+	
+	return image;
+}
+
+
+NSImage *
 _gtk_quartz_create_image_from_pixbuf (GdkPixbuf *pixbuf)
 {
   CGColorSpaceRef colorspace;
Index: gtk/gtkquartz.h
===================================================================
--- gtk/gtkquartz.h	(revision 21737)
+++ gtk/gtkquartz.h	(working copy)
@@ -41,6 +41,7 @@
 						    GtkSelectionData *selection_data);
 			
 NSImage *_gtk_quartz_create_image_from_pixbuf (GdkPixbuf *pixbuf);
+NSImage *_gtk_quartz_create_image_from_drawable (GdkDrawable *drawable);
 			    
 G_END_DECLS
 
Index: gtk/gtktooltip.c
===================================================================
--- gtk/gtktooltip.c	(revision 21737)
+++ gtk/gtktooltip.c	(working copy)
@@ -426,6 +426,7 @@
 gtk_tooltip_trigger_tooltip_query (GdkDisplay *display)
 {
   gint x, y;
+  gint rx, ry;
   GdkWindow *window;
   GdkEvent event;
 
@@ -434,10 +435,14 @@
   if (!window)
     return;
 
+  gdk_window_get_origin (window, &rx, &ry);
+
   event.type = GDK_MOTION_NOTIFY;
   event.motion.window = window;
   event.motion.x = x;
+  event.motion.x_root = rx + x;
   event.motion.y = y;
+  event.motion.y_root = ry + y;
   event.motion.is_hint = FALSE;
 
   _gtk_tooltip_handle_event (&event);
Index: gtk/gtkdnd-quartz.c
===================================================================
--- gtk/gtkdnd-quartz.c	(revision 21737)
+++ gtk/gtkdnd-quartz.c	(working copy)
@@ -1086,13 +1086,13 @@
 		GdkPixbuf *pixbuf;
 
 		pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, FALSE, 8, 1, 1);
-		gdk_pixbuf_fill (pixbuf, 0xffffff);
-	    
-		gtk_drag_set_icon_pixbuf (context,
-					  pixbuf,
+ 		gdk_pixbuf_fill (pixbuf, 0xffffff);
+
+ 		gtk_drag_set_icon_pixbuf (context,
+ 					  pixbuf,
 					  0, 0);
 
-		g_object_unref (pixbuf);
+ 		g_object_unref (pixbuf);
 	      }
 	    break;
 	  case GTK_IMAGE_PIXBUF:
@@ -1668,7 +1668,20 @@
 			  gint               hot_x,
 			  gint               hot_y)
 {
-  g_warning ("gtk_drag_set_icon_pixmap is not supported on Mac OS X");
+  GdkPixbuf *pixbuf;
+  
+  g_return_if_fail (GDK_IS_DRAG_CONTEXT (context));
+  g_return_if_fail (context->is_source);
+  g_return_if_fail (GDK_IS_COLORMAP (colormap));
+  g_return_if_fail (GDK_IS_PIXMAP (pixmap));
+  
+  pixbuf = gdk_pixbuf_get_from_drawable (NULL, pixmap, colormap,
+					 0, 0, /* src */
+					 0, 0, /* dst */
+					 -1, -1);
+  
+  gtk_drag_set_icon_pixbuf (context, pixbuf, hot_x, hot_y);
+  g_object_unref (pixbuf);
 }
 
 /**
Index: gdk/quartz/gdkevents-quartz.c
===================================================================
--- gdk/quartz/gdkevents-quartz.c	(revision 21737)
+++ gdk/quartz/gdkevents-quartz.c	(working copy)
@@ -112,6 +112,18 @@
   return ((GdkEventPrivate *) event)->windowing_data;
 }
 
+/* A category that exposes the protected carbon event for an NSEvent. */
+@interface NSEvent (GdkQuartzNSEvent)
+- (void *)gdk_quartz_event_ref;
+@end 
+
+@implementation NSEvent (GdkQuartzNSEvent)
+- (void *)gdk_quartz_event_ref
+{
+  return _eventRef;
+}
+@end
+
 void 
 _gdk_events_init (void)
 {
@@ -1670,6 +1682,65 @@
 }
 
 static gboolean
+_gdk_quartz_possibly_forward_accelerator (NSEvent* nsevent)
+{
+  /* Special-case menu shortcut events. We create command events for
+   * those and forward to the corresponding menu.
+   */
+  if ((!_gdk_quartz_keyboard_grab_window ||
+       (_gdk_quartz_keyboard_grab_window && keyboard_grab_owner_events)) &&
+      [nsevent type] == NSKeyDown)
+    {
+      EventRef event_ref;
+      MenuRef menu_ref;
+      MenuItemIndex index;
+
+      event_ref = [nsevent gdk_quartz_event_ref];
+      if (IsMenuKeyEvent (NULL, event_ref,
+                          kMenuEventQueryOnly, 
+                          &menu_ref, &index))
+        {
+          MenuCommand menu_command;
+          HICommand hi_command;
+
+          if (GetMenuItemCommandID (menu_ref, index, &menu_command) != noErr)
+            return FALSE;
+   
+          hi_command.commandID = menu_command;
+          hi_command.menu.menuRef = menu_ref;
+          hi_command.menu.menuItemIndex = index;
+
+          CreateEvent (NULL, kEventClassCommand, kEventCommandProcess, 
+                       0, kEventAttributeUserEvent, &event_ref);
+          SetEventParameter (event_ref, kEventParamDirectObject, 
+                             typeHICommand, 
+                             sizeof (HICommand), &hi_command);
+
+          SendEventToEventTarget (event_ref, GetMenuEventTarget (menu_ref));
+
+          ReleaseEvent (event_ref);
+
+          return TRUE;
+        }
+    }
+  return FALSE;
+}
+
+gboolean
+gdk_quartz_possibly_forward (GdkEvent* event)
+{
+  NSEvent *nsevent;
+  g_return_val_if_fail (event != NULL, FALSE);
+
+  nsevent = ((GdkEventPrivate*)event)->windowing_data;
+
+  if (nsevent)
+    return _gdk_quartz_possibly_forward_accelerator (nsevent);
+
+  return FALSE;
+}
+
+static gboolean
 gdk_event_translate (NSEvent *nsevent)
 {
   NSWindow *nswindow;
